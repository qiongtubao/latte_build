#!/usr/bin/env node
(function(define) {'use strict'
	define("latte/build", ["require", "exports", "module", "window"], 
		function(require, exports, module, window) {
			var GetConfig = function() {
				var config;
				var index = process.argv.indexOf("-c");
				if(index != -1) {
					config = process.argv[index+1];
				}
				config = config || ".latte/build.json";
				var buildConfigPath = Path.join(process.cwd()+"/"+config);
				var buildConfig;
				try {
					buildConfig = require(buildConfigPath);
				}catch(e) {
					return null;
				}
				return buildConfig;
			};
			var GetPackageJson = function() {
				var packageJson;
				try {
					packageJson = require(process.cwd() + "/" + "package.json");
				}catch(e) {
					packageJson = {};
				}
				return packageJson;
			}
			var build = function() {
				//get config
				var config = GetConfig();
	 			if(!config) {
	 				return console.log("not find config");
	 			}
	 			//get packageJson
	 			var packageJson = GetPackageJson();			
				var config = JSON.parse(
		           latte_lib.format.templateStringFormat(JSON.stringify(config), packageJson)
	         	);
	         	var buildFunc ,cleanFunc;
	         	buildFunc = cleanFunc = function(callback) {
	         		callback && callback();
	         	};

	         	if(config.clean) {
	         		cleanFunc = function(callback) {
	         			var funcs = config.clean.map(function(command) {
		         			var handle = build.clean[command.command];
			             	if(!handle) {
			             		throw "no find module " + command.command; 
			             	}
			             	return handle(command, config);
		         		});
		         		latte_lib.async.series(funcs, function(error) {
				             if(error) {
				               console.log("clean not ok");
				               return 
				             }
				             callback && callback();
				             //console.log("build ok!");
			         	});
	         		}
	         	}

	         	if(config.build) {
	         		buildFunc = function(callback) {
	         			var funcs = config.build.map(function(command) {	             	
			             	var handle = build.build[command.command];
			             	if(!handle) {
			             		throw "no find module " + command.command; 
			             	}
			             	return handle(command, config);
			         	});
			         	latte_lib.async.series(funcs, function(error) {
				             if(error) {
				               console.log("buiild not ok");
				               return clean();
				             }
				             
			         	});
	         		}
	         		
	         	}
	         	cleanFunc(function(err) {
	         		//console.log("clean ok");
	         		buildFunc();
	         	});
			};

			(function() {
				this.build = {};
				this.clean = {};
			}).call(build);
			(function() {
				/**
				this.mergerFile = function(command, keys){
					return function(callback) {
						var files = [];
						var cwd = process.cwd();
						var type = "." + command.type || ".js";
						var read = function(path) {
							if(!command.ignores || command.ignores.indexOf(path) == -1) {
								var stat = Fs.lstatSync(cwd + "/" + path);
								if(stat.isFile()) {
									if(Path.extname(path) == type) {
										file.push(path);
									}
								}else if(stat.isDirectory()) {
									Fs.readdirSync(path).forEach(function(filename) {
										read(path + "/" + filename);
									});
								}else if(stat.isSymbolicLink()) {
									try {
										Fs.readdirSync(path).forEach(function(filename) {
											read(path + "/" + filename);
										});
									}catch(e) {
										files.push(path);
									}
								}
							}
						}
						command.in.forEach(function(filename) {
							read(filename);
						});
						var datas = files.map(function(filename) {
							return Fs.readFileSync(cwd + "/" + filename);
						});
						var time = Date.now();
						var data = datas.join("\n");
						data = latte_lib.format.templateStringFormat(data, keys);
						latte_lib.fs.writeFileSync(cwd + "/"+command.out , data);
						console.log("mergerFile over:", Date.now() - time + "ms");
					}
				}
				*/
				var self = this;
				this.mini = function(command, keys) {
					if(command.out[command.out.length - 1] == "/") {
						command.mini = 1;
						return self.merger(command, keys);
					}else{
						command.mini = 1;
						return self.copy(command, key);
					}
				}

				this.merger = function(command, keys) {
					return function(callback) {
						var files = [];
						var cwd = process.cwd();
						//var type = "." + command.type || ".js";
						var read = function(path) {
							if(!command.ignores || command.ignores.indexOf(path) == -1) {
								var stat = Fs.lstatSync(cwd + "/" + path);
								if(stat.isFile()) {
									if(Path.extname(path) == type) {
										if(!command.mini) {
											files.push(Fs.readFileSync(cwd + "/" + filename));
										}else{
											files.push(cwd + "/" + filename);
										}
										
									}
								}else if(stat.isDirectory()) {
									Fs.readdirSync(path).forEach(function(filename) {
										read(path + "/" + filename);
									});
								}else if(stat.isSymbolicLink()) {
									try {
										Fs.readdirSync(path).forEach(function(filename) {
											read(path + "/" + filename);
										});
									}catch(e) {
										if(!command.mini) {
											files.push(Fs.readFileSync(cwd + "/" + filename));
										else{
											files.push(cwd + "/" + filename);
										}										
									}
								}
							}
						}
						command.in.forEach(function(filename) {
							read(filename);
						});
						/*
						var datas = files.map(function(filename) {
							return Fs.readFileSync(cwd + "/" + filename);
						});
						*/
						var time = Date.now();
						if(!command.mini) {
							var data = files.join("\n");
							data = latte_lib.format.templateStringFormat(data, keys);
							latte_lib.fs.writeFileSync(cwd + "/"+command.out , data);
							console.log("mergerFile over:", Date.now() - time + "ms");
						}else{
							var result = uglifyJs.minify(files);
							var data = latte_lib.format.templateStringFormat(result.code, keys);
							Fs.writeFile(command.out , data, callback);
						}
						
					}
				}

				this.copy = function(command, keys) {
					return function(callback) {
						var files = [];
						var cwd = process.cwd();
						var read = function(dir, path) {
							if(!command.ignores || command.ignores.indexOf(path) == -1) {
								var stat = Fs.lstatSync(cwd + "/" + dir + path);
								if(stat.isFile()) {
									var type = Path.extname(path);
									if(command.types.indexOf(type) != -1) {
										files.push({
											key: cwd + "/" + dir + path,
											value: cwd + "/" + command.out + path
										})
									}
								}else{
									Fs.mkdirSync(Path.dirname(cwd + "/" + command.out  + path));
									Fs.readdirSync(dir + path).forEach(function(filename) {
										read(dir, path + "/" + filename);
									});
								}
							}
						}
						if(!latte_lib.isArray(command.in)) {
							command.in = [command.in];
						}
						command.in.forEach(function(filename) {
							read(filename, "");
						});
						var cpus =  require("os").cpus().length;
						if(files.length > cpus) {
							var time = Date.now();
							var runs = [];
							var allLength = files.length;
							var access = 0;
							var fp = function(work) {
								var o = files.shift();
								if(!o) {
									work.kill();
									if(runs.length == 0) {
										console.log("copy over :", access, allLength, Date.now() - time + "ms" );
										callback();
									}
									return;
								}
								runs.push(o.key);
								work.send({
									type: "copy",
									key: o.key,
									value: o.value,
									mini: command.mini
								});
							}
							var fpok = function(m, work) {
								var index = runs.indexOf(m.key);
								if(index != -1) {
									runs.splice(index, 1);
								}
								if(m.err) {
									files.push({
										key: m.key,
										value: m.value
									});
								}else{
									access++;
								}
								fp(work);
							}
							var childs = [];
							var createWork = function(i) {
								var work = child.fork(Path.join(__dirname, "../lib/child.js"));
								work.id = i;
								work.on("message", function(m) {
									fpok(m, work);
								});
								work.on("error", function(){
									createWork(work.id);
								});
								fp(work);
								childs[i] = work;
							}
							for(var i = 0, len = cpus * 2; i < len; i++) {
								createWork(i);
							}
						}else{
							var copyModule = require("../lib/copy");
							var time = Date.now();
							var funcs = files.map(function(o) {
								return function(cb) {
									copyModule(o.key, o.value, command.mini, cb);
								}
							});
							latte_lib.async.parallel(funcs, function() {
								console.log("copy over :", files.length, files.length, Date.now() - time + "ms");
								callback();
							});
						}
						
					}
				}


				
			}).call(build.build);
			(function() {
				this.clean = function(command, keys) {
					var removeDir = function(dirName, callback) {
						var exec = require("child_process").exec, child;
						child = exec("rm -rf "+dirName, function(err, out) {
							err && console.log(err);
							callback(err);
						});
					}
					var removeFile = function(fileName, callback) {
						latte_lib.fs.unlinkSync(dirName);
						callback();
					}
					return function(callback) {
						try {
							var stat = latte_lib.fs.lstatSync(command.in);
						}catch(e) {
							return callback();
						}

						if(stat.isDirectory()) {
							removeDir(command.in, callback);
						}else{
							removeFile(command.in, callback);
						}
					}
				}
			}).call(build.clean);
			(function() {

			}).call(build.clean);
			module.exports = build;
		});
})(typeof define === "function"? define: function(name, reqs, factory) { factory(require, exports, module); });